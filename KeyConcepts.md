# Introduction #

System# is a _system-level design language_ (SLDL). It's intent is to support the description of real-time embedded systems at different levels of abstraction. Precisely, System# is not a language on its own. Neither is it a new programming language, nor does it modify the syntax of any existing language. From a technological point of view, it's just a .NET library which provides the building blocks needed to construct, simulate and translate system models.

So why do we call it a language then? That's because System# comes with a bunch of design rules and coding guidelines. You're _not_ completely free in how you code your design. Just that your code is compilable and even runs without throwing an exception does not mean it's a valid System# design. If you want to create re-usable designs and if you want the System# framework to analyze and translate your design, you'd better adhere to the rules. That's why we call System# a _domain-specific embedded language_ (DSEL). Theoretically, you can use any .NET-enabled language to implement your design. However, we recommend C# as it provides just the right syntactic sugar needed you describe System# designs efficiently.

# Why yet-another-SLDL? #

You're probably familiar with other SLDLs, such as SystemVerilog and SystemC. These widespread and matured languages assemble are large community, are supported by many EDA tools and proved their practicability in countless academic and industrial applications. So why System#? To come to the point:
  * .NET is a powerful framework whose capabilities go far beyond the built-in features of C/C++ and its standard libraries. Why not make them available to system and hardware developers?
  * C# comes with a lot of syntactical simplifications over C/C++. Maybe, you'll find this [MSDN article](http://msdn.microsoft.com/en-us/magazine/cc301505.aspx) interesting. Despite the article dates to the year 2000, it is still true when compared to the new C++11 standard.
  * Did you ever try to develop some automated code analysis for SystemC? You'll soon find out that programmatic analysis of SystemC models is extremely hard to implement. You need to setup a C++ parser and make it understand the SystemC-specific parts. Strictly speaking, a SystemC model does not exist until it is _elaborated_. So you need to execute the elaboration part of the SystemC design, inspect its program space and combine this information with the abstract syntax tree generated by your parser. Intricate! That's why SystemC synthesis is supported by only few commercially-available wickedly expensive tools. The .NET framework, however, simplifies things a lot: It provides a powerful reflection API and requires application binaries to be encoded in a standardized platform-independent intermediate representation: the Common Intermediate Language (CIL). CIL was indeed designed for manageable program analysis: Any CIL just-in-time compiler applies inference techniques in order to deliver optimal target code. With the help of reflection and CIL analysis, System# is able to provide a clean reflection interface for system-level designs. This interface is used for model-to-model transformations and implementation code synthesis. A major goal of System# is to provide researchers an open and flexible integration platform to prototype behavioral synthesis algorithms, model-to-model transformations, code generators and applications we didn't even think of.
  * Last but not least: We don't state that System# is "better than any other SLDL" - would be kind of overbold, wouldn't it? However, we **do** think that it **is** worth exploring how system-level modeling might look like in .NET and what can be achieved by doing so.

# System# modeling #

If you're familiar with SystemC and/or VHDL, you'll find that things are very similar in System#. The following table will give you a brief overview:

| **VHDL concept** | **SystemC concept** | **System# concept** |
|:-----------------|:--------------------|:--------------------|
| `entity`/`architecture` | derive from `sc_module` | derive from `Component` |
| `component` | `sc_module` instance | `Component` instance |
| `port` | `sc_port<type>` | C# property of `type` |
| `signal` | `sc_signal<type>` | `Signal<type>` |
| `process` without `wait` statements | call to `sc_process()` | call to `AddProcess()` |
| `process` with `wait` statements | call to `sc_thread()` | call to `AddThread()` |
| n.a. | clocked thread | call to `AddClockedThread()` |

The next subsections will dive into the details. All code examples are given in C#.

## Components and hierarchical composition ##

A System# design is hierachically composed of _components_. A component encapsulates the behavior of a certain design part and can itself contain further components. To declare a component type, derive a class from `SystemSharp.Components`:
```cs

import SystemSharp.Components;

class MyComponent: Component
{
}
```
If your component class shall contain a child component, just declare it as a field and instantiate them inside the constructor:
```cs

class MyTopComponent: Component
{
private MyComponent child;

public MyTopComponent()
{
child = new MyComponent();
}
}
```

## Component interfaces: Ports ##

The only way for a component to interact with its environment is through _ports_. A port can be thought as of an interface which exposes a certain functionality to the component. In hardware design, a port models a discrete signal input or output. In System#, ports are described by C# properties. System# ports are _always_ assigned from outside the component (a process called _binding_) and read from _inside_. Therefore, a port property has a `public` `set`-accessor and a `private` `get`-accessor (yes, the accessor modifications are converse compared to usual programming practice).
  * Signal input ports are declared through a property of type `In<Type>` where `Type` is the signal value data type.
  * Signal output ports are declared through a property of type `Out<Type>` where `Type` is the signal value data type.
  * Bidirectional signal ports are declared through a property of type `InOut<Type>` where `Type` is the signal value data type.
  * Of course, it is also possible to declare ports of non-signal types. Just adhere to the concept and use C# properties. However, don't expect any useful VHDL translation.
Let's declare a component having a `bool`-valued input, an `StdLogic`-valued input, an `int`-valued output and an `StdLogicVector`-valued output:
```cs

class MyComponent: Component
{
public In<bool> In1 { private get; set; }
public In<StdLogic> In2 { private get; set; }
public Out<int> Out1 { private get; set; }
public Out<StdLogicVector> Out2 { private get; set; }
}
```
Now assume that some other component, `MyTopComponent`, instantiates `MyComponent` as child component. Then `MyTopComponent` is responsible for associating each port of `MyComponent` with an appropriate signal instance (signals are discussed later). This process is called binding and is attended best by using the `Bind()` method which expects a delegate which describes the bind operations to be carried out:
```cs

class MyTopComponent: Component
{
private MySubComponent child;

private Signal<bool> sig1 = new Signal<bool>();
private SLSignal sig2 = new SLSignal();
private Signal<int> sig3 = new Signal<int>();
private SLVSignal sig4 = new SLVSignal();

public MyTopComponent()
{
child = new MySubComponent();
Bind(() => {
child.In1 = sig1;
child.In2 = sig2;
child.Out1 = sig3;
child.Out2 = sig4;
});
}
}
```

## Channels and signals ##

Ports constitute a component's interface. We still need a thing which stores the actual information which is exchanged by ports, a thing where we can bind those ports to. This thing is called a _channel_. Whereas a component encapsulates the _computation_ which takes place inside a system part, a channel models _communication_. In hardware design, the most popular realization of a channel is a signal.

`Channel` (namespace: `SystemSharp.Components`) is System#'s abstract base class used for all channel realizations. Signals are implemented by class `Signal<Type>`. `Type` is a generic type parameter and depicts the data type of the carried signal value. System# offers special signal implementations for resolved data types.
  * Class `SLSignal` is a signal of data type `StdLogic`.
  * Class `SLVSignal` is a signal of data type `StdLogicVector`. `SLVSignal` needs one constructor argument which tells the desired width of the stored logic vector.
  * Use `Signal<Type>` for any other data type.

Data access to signals is governed by a set of properties:
| **Property name** | **Access restrictions** | **Description** |
|:------------------|:------------------------|:----------------|
| `InitialValue` | read/write. Only before simulation. | Sets/gets the signal's value at simulation time 0. |
| `Cur` | read-only. Only during simulation. | Gets the signal's value. |
| `Next` | write-only. Only during simulation. | Sets the signal's value. |
| `Pre` | read-only. Only during simulation. | Gets the value the signal had prior to the current event. |

The preset of `InitialValue` for...
  * an `SLSignal` instance is `'U'`,
  * an `SLVSignal` instance is `'UUU...U'`,
  * a `Signal<Type>` is `default(Type)`.

## Processes ##

A process is the place where actual design action occurs. Technologically, a process is a method without any arguments. However, it has a special meaning in that a process acts like a program's `main` function. As we're modeling a concurrent system, there are multiple `main` functions in parallel.

System# distinguishes three kind of processes:
  * A **triggered process** executes its implementing method due to some event. The set of events which are capable of triggering the process is specified inside the process _sensitivity list_. A triggered process consumes no (simulation) time during its execution. Thus, it may not call any of the `DesignContext.Wait(...)` methods.
  * A **threaded process** starts executing its implementing method from the very beginning. It incorporates the `DesignContext.Wait(...)` methods to pause its execution until some event occurs.
  * A **clocked thread** is a special threaded process and especially useful to model synthesizable synchronous finite state machines. The clocked thread pre-defines its sensitivity the rising or falling edge event of a clock signal. It is only allowed to call `DesignContext.Wait()` (without any arguments) which will pause its execution for one clock cycle.
To turn a method into a process, the method must be registered by a special framework call. The registration must take place inside the overwritten `Initialize` method of a component. Which framework call to use depends on the process kind. Assume the method to be registered has the identifier `MyMethod`:
| **Task** | **Syntax** | **Remarks** |
|:---------|:-----------|:------------|
| Register a **triggered process** | `AddProcess(MyMethod, ...)` | The sensitivity list is specified by the following arguments |
| Register a **threaded process** | `AddThread(MyMethod)` |  |
| Register a **clocked thread** | `AddClockedThread(MyMethod, Clk.RisingEdge, Clk)` or<br> <code>AddClockedThread(MyMethod, Clk.FallingEdge, Clk)</code> <table><thead><th> <code>Clk</code> depicts the desired clock signal. It must be of type <code>StdLogic</code> or <code>bool</code>. </th></thead><tbody></li></ul></tbody></table>

<h3>Example: Counter with triggered process ###

The following example describes a synchronous binary n-bit counter. The increment process is realized using a triggered process:

```cs

class Counter : Component
{
public In<StdLogic> Clk { private get; set; }
public Out<StdLogicVector> Ctr { private get; set; }

private SLVSignal _ctr;

public Counter(int width)
{
_ctr = new SLVSignal(StdLogicVector._1s(width));
}

private void Processing()
{
if (Clk.RisingEdge())
{
Ctr.Next = _ctr.Cur;
_ctr.Next = _ctr.Cur + "1";
}
}

protected override void Initialize()
{
// Triggered process is registered here
AddProcess(Processing, Clk);
}
}
```

### Example: Counter with threaded process ###

The following example replaces the triggered process by a threaded one.

```cs

class Counter : Component
{
public In<StdLogic> Clk { private get; set; }
public Out<StdLogicVector> Ctr { private get; set; }

private SLVSignal _ctr;

public Counter(int width)
{
_ctr = new SLVSignal(StdLogicVector._1s(width));
}

private void Processing()
{
// The following while-loop is actually redundant: A threaded process is
// implicitly embedded in a while (true) loop.
while (true)
{
DesignContext.Wait(Clk);
if (Clk.RisingEdge())
{
Ctr.Next = _ctr.Cur;
_ctr.Next = _ctr.Cur + "1";
}
}
}

protected override void Initialize()
{
// Threaded process is registered here
AddThread(Processing);
}
}
```

### Example: Counter with clocked thread ###

And a third example incorporating a clocked thread.

```cs

class Counter : Component
{
public In<StdLogic> Clk { private get; set; }
public Out<StdLogicVector> Ctr { private get; set; }

private SLVSignal _ctr;

public Counter(int width)
{
_ctr = new SLVSignal(StdLogicVector._1s(width));
}

private void Processing()
{
// The following while-loop is actually redundant: A threaded process is
// implicitly embedded in a while (true) loop.
while (true)
{
DesignContext.Wait();
Ctr.Next = _ctr.Cur;
_ctr.Next = _ctr.Cur + "1";
}
}

protected override void Initialize()
{
// Clocked thread is registered here
AddClockedThread(Processing, Clk.RisingEdge, Clk);
}
}
```

## Hardware datatypes ##

The `SystemSharp.DataTypes` namespace contains bit-accurate datatypes and resolved logic.

### Resolved logic ###

`StdLogic` ist the counterpart to VHDL's `std_logic`. The datatype implements implicit conversions from and to `char`, so the syntax is very similar to VHDL. To instantiate an `StdLogic`-valued signal, use class `SLSignal`. It was designed to support resolved logic.

As might guess it, System# `StdLogicVector` is the equivalent to VHDL `std_logic_vector`. Again, an implicit conversion operator lets you assign any `StdLogicVector` from a string. Compared to VHDL, an `StdLogicVector v` is always assumed to have an implicitly defined range of `v.Size - 1 downto 0`. Operator overloads provide access to single bits and slices:
```cs

import SystemSharp.DataTypes;
...
StdLogicVector v = "1010ZU-"; // assigns an StdLogicVector, VHDL range: range 6 downto 0
StdLogic bit = v[2]; // returns StdLogic._Z
StdLogicVector slice = v[5, 1]; returns StdLogicVector("010ZU")
```
To instantiate an `StdLogicVector`-valued signal, use class `SLVSignal`. It provides appropriate operators to drive dedicated portions of a signal:
```cs

import SystemSharp.DataTypes;
...
SLVSignal sig = new SLVSignal(8);
...
StdLogic bit1 = sig.Cur[0];
StdLogic bit2 = sig[0].Cur;
// Both lines are equvialent, so we have: bit1.Equals(bit2)

sig.Next[1] = '0'; // Error! Not allowed!
sig[1].Next = '0'; // OK
```

## Arbitrary-length integers ##

The System# datatypes `Signed` and `Unsigned` provide implementations of arbitrary-length integers. They are mapped to the VHDL datatypes `signed`  and `unsigned`, respectively. Static helper methods let you create instances of these datatypes form native C# data types or from the underlying arbitrary-length integer implementation `IntX`:

| **Method** | **Description** |
|:-----------|:----------------|
| `Signed.FromInt(i, size)` | Converts integer value `i` to a `Signed` instance having a size of `size` bits. |
| `Signed.FromLong(i, size)` | Converts long integer value `i` to a `Signed` instance having a size of `size` bits. |
| `Signed.FromIntX(i, size)` | Converts `IntX` value `i` to a `Signed` instance having a size of `size` bits. |
| `Unsigned.FromUInt(i, size)` | Converts unsigned integer value `i` to an `Unsigned` instance having a size of `size` bits. |
| `Unsigned.FromULong(i, size)` | Converts unsigned long integer value `i` to an `Unsigned` instance having a size of `size` bits. |
| `Unsigned.FromIntX(i, size)` | Converts `IntX` value `i` to an `Unsigned` instance having a size of `size` bits. |

To convert any `Signed` or `Unsigned` value to its binary 2's complement encoding, you can use the property `SLVValue`:
```cs

import SystemSharp.DataTypes;
...
Signed value = Signed.FromInt(-2, 8);
StdLogicVector slv = value.SLVValue; // returns StdLogicVector("11111110");
```

## Fixed-point arithmetic ##

Fixed-point arithmetic is supported by the System# datatypes `SFix` (signed fixed-point value) and `UFix` (unsigned fixed-point value). These are mapped to the VHDL datatypes `sfixed` and `ufixed`, respectively. The following table gives you an overview about the possibilities to construct instances of `SFix` and `UFix`:

| **Method** | **Description** |
|:-----------|:----------------|
| `SFix.FromSigned(value, intWidth, fracWidth)` | Scales `Signed value` by a factor of 2<sup>-fracWidth</sup> and returns the `SFix` result. |
| `SFix.FromDouble(value, intWidth, fracWidth)` | Converts `double value` to an `SFix`, having an integer width of `intWidth` and a fractional width of `fracWidth`. |
| `UFix.FromUnsigned(value, intWidth, fracWidth)` | Scales `Unsigned value` by a factor of 2<sup>-fracWidth</sup> and returns the `UFix` result. |
| `UFix.FromDouble(value, intWidth, fracWidth)` | Converts `double value` to a `UFix`, having an integer width of `intWidth` and a fractional width of `fracWidth`. |

It is also possible to convert an `SFix` or `UFix` value back to a `Signed`, `Unsigned`, `double` or `StdLogicVector`. Be `value` an instance of `SFix`. Then
  * `value.SignedValue` scales `value` by 2<sup>n</sup> (n is its fractional width) and returns the result as `Signed`.
  * `value.DoubleValue` converts `value` to its `double` (floating point) representation.
  * `value.SignedValue.SLVValue` converts `value` to its binary two's complement encoding.

Now the same for `value` being a `UFix`:
  * `value.UnsignedValue` scales `value` by 2<sup>n</sup> (n is its fractional width) and returns the result as `Unsigned`.
  * `value.DoubleValue` converts `value` to its `double` (floating point) representation.
  * `value.SignedValue.SLVValue` converts `value` to its binary encoding.

Both datatypes `SFix` and `UFix` overload operators for standard arithmetic operations. To convert an `SFix` or `UFix` value to a different fixed-point format, both datatypes implement a method `Resize(newIntWidth, newFracWidth)` which takes the desired integer and fractional widths as input arguments. If the new integer width is bigger than the current width, the result is padded to the left. It case of an `SFix` the sign is extended whereas a `UFix` value is left-padded by zeroes. If the new integer width is smaller, overlapping integer bits are truncated. If the new fractional width is bigger, the value is right-padded by zeroes. If the new fractional width is smaller, overlapping fractional bits are truncated.

# Elaboration #

System# shares the concept of elaboration with SystemC and VHDL. Elaboration is the point where a system design is made ready for simulation, analysis and program transformations, such as translation to VHDL. It is important to understand that before and after elaboration, things are fundamentally different: Whereas before elaboration, a System# model is free to do almost anything, elaboration will freeze the system design in certain aspects. Once a design is elaborated, you are not allowed to add new processes, create new signals or add new components to it.
SystemC elaborates a design automatically as soon as to start the simulation. In contrast, System# defines a separate method call which lets you trigger elaboration:
```cs

DesignContext.Instance.Elaborate();
```
We made this explicit because elaboration is not only a prerequisite to simulation but also to design analysis and translation. So we wanted to leave the designer in control when elaboration happens.

# Simulation #

Simulation is controlled by a call to `DesignContext.Instance.Simulate(Time delta)`. The `delta` argument specifies what amount of simulated time the simulation should run. E.g.
```cs

DesignContext.Instance.Simulate(new Time(60.0, ETimeUnit.sec));
```
simulates 60 seconds of system runtime. It is possible to continue simulation by succeeding calls to `Simulate`.

# Translation #

System# was designed with synthesis in mind. It provides a convenient interface to translate an elaborated design to some implementation-level language. However, VHDL is currently the only supported language. The translation of a design basically consists of three steps:
  * Create a container project for your design.
  * Create an appropriate code generator.
  * Perform the design translation given the container project and the code generator.

The following code snippet demonstrates how to translate a design to VHDL, saving it in a Xilinx ISE container project:
```cs

using SystemSharp.Synthesis;
using SystemSharp.Synthesis.VHDLGen;
using SystemSharp.Interop.Xilinx;

...

// Create a Xilinx ISE project containing the generated sources.
//  1st argument is the desired output path
//  2nd argument is the project name
XilinxProject project = new XilinxProject(@".\hdl_output", "MyDesign");

// Configure project-specific options
project.PutProperty(EXilinxProjectProperties.DeviceFamily, EDeviceFamily.Spartan3);
project.PutProperty(EXilinxProjectProperties.Device, EDevice.xc3s1500l);
project.PutProperty(EXilinxProjectProperties.Package, EPackage.fg676);
project.PutProperty(EXilinxProjectProperties.SpeedGrade, ESpeedGrade._4);
project.PutProperty(EXilinxProjectProperties.PreferredLanguage, EHDL.VHDL);

// Instantiate the VHDL code generator
VHDLGenerator codeGen = new VHDLGenerator();

// Advise the synthesis engine to translate the design
SynthesisEngine.Synthesize(DesignContext.Instance, project, codeGen);

// Don't forget to save the project
project.Save();
```